import React, {useState, useEffect, useRef} from 'react';
import {
  View,
  StyleSheet,
  PermissionsAndroid,
  Platform,
  TouchableOpacity,
  Text,
  Alert,
  ScrollView,
} from 'react-native';
import Geolocation from 'react-native-geolocation-service';
import {Card, Title, Provider as PaperProvider} from 'react-native-paper';
import ProfileCard from './ProfileCard';
import {useNavigation} from '@react-navigation/native';
import Toast from 'react-native-root-toast';
import Tts from 'react-native-tts';
// Import accelerometer APIs from react-native-sensors.
import {
  accelerometer,
  setUpdateIntervalForType,
  SensorTypes,
} from 'react-native-sensors';

// ----------------------------------------------------------------
// Constants & Global Variables
// ----------------------------------------------------------------
const PICKUP_RADIUS = 15;
// Fixed threshold (in meters) for updating cumulative distance.
// Instead of requiring a single update to exceed 2m, we will accumulate increments.
const BASE_DISTANCE_THRESHOLD = 2;
const LPF_ALPHA = 0.8; // Low-pass filter constant for smoothing GPS coordinates
let currentToast = null;

// Threshold for detecting stillness (accelerometer change on each axis)
const STANDING_STILL_THRESHOLD = 0.1;

// ----------------------------------------------------------------
// Request Permissions (Location & Body Sensors)
// ----------------------------------------------------------------
const requestPermissions = async () => {
  if (Platform.OS === 'android') {
    const locationGranted = await PermissionsAndroid.request(
      PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
      {
        title: 'Location Permission',
        message: 'This app needs access to your location for tracking.',
        buttonNeutral: 'Ask Me Later',
        buttonNegative: 'Cancel',
        buttonPositive: 'OK',
      },
    );
    const bodySensorsGranted = await PermissionsAndroid.request(
      PermissionsAndroid.PERMISSIONS.BODY_SENSORS,
      {
        title: 'Body Sensors Permission',
        message: 'This app needs access to your body sensors for tracking.',
        buttonNeutral: 'Ask Me Later',
        buttonNegative: 'Cancel',
        buttonPositive: 'OK',
      },
    );
    return (
      locationGranted === PermissionsAndroid.RESULTS.GRANTED &&
      bodySensorsGranted === PermissionsAndroid.RESULTS.GRANTED
    );
  }
  return true;
};

// ----------------------------------------------------------------
// Toast Notification for Jerk Detection (Placeholder)
// ----------------------------------------------------------------
const showToastNotification = (cause, intensity) => {
  if (currentToast !== null) {
    Toast.hide(currentToast);
    currentToast = null;
  }
  const toastContent = (
    <View style={toastStyles.container}>
      <Text style={toastStyles.causeText} numberOfLines={1}>
        {cause} Detected
      </Text>
      <Text style={toastStyles.intensityText} numberOfLines={1}>
        Intensity: {intensity}
      </Text>
    </View>
  );
  currentToast = Toast.show(toastContent, {
    duration: 3000,
    position: Toast.positions.TOP,
    shadow: false,
    animation: true,
    hideOnPress: true,
    delay: 0,
    containerStyle: {
      backgroundColor: '#E6E6FA',
      borderColor: '#6200ee',
      borderWidth: 2,
      borderRadius: 14,
      padding: 16,
      elevation: 0,
      shadowColor: 'transparent',
      shadowOpacity: 2,
      shadowOffset: {width: 0, height: 0},
      width: '95%',
      alignSelf: 'center',
    },
  });
};

// ----------------------------------------------------------------
// Main App Component
// ----------------------------------------------------------------
export default function App() {
  const navigation = useNavigation();
  const isIOS = Platform.OS === 'ios';

  // State Variables
  const [location, setLocation] = useState(null);
  const [speed, setSpeed] = useState(0);
  const [tracking, setTracking] = useState(false);
  const [paused, setPaused] = useState(false);
  const [startTime, setStartTime] = useState(null);
  const [distanceTraveled, setDistanceTraveled] = useState(0);
  const [averageSpeed, setAverageSpeed] = useState(0);
  const [duration, setDuration] = useState(0);
  const [showResults, setShowResults] = useState(false);
  const [countdown, setCountdown] = useState(null);
  // New state for stop details
  const [stops, setStops] = useState([]);

  // Refs for storing subscriptions and previous values
  const locationSubscription = useRef(null);
  const lastLocation = useRef(null);
  const lastLocationTimeRef = useRef(null);
  const speedReadings = useRef([]);
  // Holds the low-pass filtered location used for distance calculation.
  const filteredLocation = useRef(null);
  // Buffer to accumulate small increments of distance.
  const distanceBuffer = useRef(0);

  // Refs for accelerometer and stop detection
  const currentStopStartRef = useRef(null);
  const stillAlertTimeoutRef = useRef(null);
  const lastAccelerationRef = useRef(null);
  const accelerometerSubscription = useRef(null);

  // ----------------------------------------------------------------
  // Utility: Finalize Stop Detection
  // ----------------------------------------------------------------
  const finalizeStop = () => {
    if (!currentStopStartRef.current) return;
    const stopStart = currentStopStartRef.current;
    const stopDuration = Date.now() - stopStart;
    if (stillAlertTimeoutRef.current) {
      clearTimeout(stillAlertTimeoutRef.current);
      stillAlertTimeoutRef.current = null;
    }
    // Record stop only if duration is 15 seconds or more.
    if (stopDuration >= 15000) {
      setStops(prevStops => [
        ...prevStops,
        {startTime: stopStart, endTime: Date.now(), duration: stopDuration},
      ]);
    }
    currentStopStartRef.current = null;
  };

  // ----------------------------------------------------------------
  // useEffect: Initialize TTS & Request iOS Location Permission
  // ----------------------------------------------------------------
  useEffect(() => {
    Tts.setDefaultLanguage('en-US');
    if (Platform.OS === 'android') {
      Tts.setDefaultRate(0.5);
    }
    Tts.setDefaultPitch(1.0);

    if (isIOS) {
      Geolocation.requestAuthorization('whenInUse');
    }
    // Cleanup on unmount
    return () => {
      stopAllSensors();
    };
  }, [isIOS]);

  // ----------------------------------------------------------------
  // Accelerometer Subscription for Stop Detection
  // ----------------------------------------------------------------
  useEffect(() => {
    if (tracking) {
      // Reset stops when a new journey starts.
      setStops([]);
      // Set the accelerometer update interval (in ms)
      setUpdateIntervalForType(SensorTypes.accelerometer, 100);
      accelerometerSubscription.current = accelerometer.subscribe(
        ({x, y, z}) => {
          if (lastAccelerationRef.current) {
            const diffX = Math.abs(x - lastAccelerationRef.current.x);
            const diffY = Math.abs(y - lastAccelerationRef.current.y);
            const diffZ = Math.abs(z - lastAccelerationRef.current.z);
            // If changes are below threshold, consider the device still.
            if (
              diffX < STANDING_STILL_THRESHOLD &&
              diffY < STANDING_STILL_THRESHOLD &&
              diffZ < STANDING_STILL_THRESHOLD
            ) {
              // If not already marked as stopped, initiate a stop.
              if (!currentStopStartRef.current) {
                currentStopStartRef.current = Date.now();
                stillAlertTimeoutRef.current = setTimeout(() => {
                  Alert.alert(
                    'Assistance Alert',
                    'You have been stationary for 15 seconds. Assistance may be required.',
                  );
                }, 15000);
              }
            } else {
              // Movement detected; if a stop was in progress, finalize it.
              if (currentStopStartRef.current) {
                finalizeStop();
              }
            }
          }
          lastAccelerationRef.current = {x, y, z};
        },
      );
    } else {
      // If tracking stops, unsubscribe and finalize any ongoing stop.
      if (accelerometerSubscription.current) {
        accelerometerSubscription.current.unsubscribe();
        accelerometerSubscription.current = null;
      }
      finalizeStop();
    }
    return () => {
      if (accelerometerSubscription.current) {
        accelerometerSubscription.current.unsubscribe();
        accelerometerSubscription.current = null;
      }
    };
  }, [tracking]);

  // ----------------------------------------------------------------
  // Start Tracking: Request Permissions and Get Starting Point
  // ----------------------------------------------------------------
  const startTrackingFunc = async () => {
    const hasPermission = await requestPermissions();
    if (!hasPermission) {
      Alert.alert(
        'Permissions Required',
        'Location and Body Sensors permissions are required for tracking.',
      );
      return;
    }
    Geolocation.getCurrentPosition(
      position => {
        // Announce start using TTS
        Tts.speak('Tracking started');
        beginTracking();
      },
      error => {
        console.log('Location Error: ', error);
        Alert.alert(
          'Location Error',
          'Unable to get your current location. Please check your permissions and try again.',
        );
      },
      {enableHighAccuracy: true, timeout: 15000, maximumAge: 10000},
    );
  };

  // ----------------------------------------------------------------
  // Begin Tracking: Initialize States and Start Location Watch
  // ----------------------------------------------------------------
  const beginTracking = () => {
    setTracking(true);
    setPaused(false);
    setStartTime(Date.now());
    speedReadings.current = [];
    setDistanceTraveled(0);
    lastLocation.current = null;
    lastLocationTimeRef.current = null;
    filteredLocation.current = null;
    distanceBuffer.current = 0;
    // Reset stop detection refs.
    currentStopStartRef.current = null;
    if (stillAlertTimeoutRef.current) {
      clearTimeout(stillAlertTimeoutRef.current);
      stillAlertTimeoutRef.current = null;
    }

    // Start watching the user's location
    locationSubscription.current = Geolocation.watchPosition(
      position => {
        if (!paused) {
          const {coords} = position;
          const rawLat = coords.latitude;
          const rawLon = coords.longitude;
          const now = Date.now();

          // --- Speed Calculation (unchanged) ---
          let computedSpeed = 0;
          if (
            Platform.OS === 'ios' &&
            coords.speed != null &&
            coords.speed >= 0
          ) {
            computedSpeed = coords.speed;
          } else if (lastLocation.current && lastLocationTimeRef.current) {
            const dt = (now - lastLocationTimeRef.current) / 1000;
            const dist = calculateDistance(lastLocation.current, {
              latitude: rawLat,
              longitude: rawLon,
            });
            computedSpeed = dt > 0 ? dist / dt : 0;
          }
          lastLocationTimeRef.current = now;
          setSpeed(computedSpeed);
          speedReadings.current.push(computedSpeed);
          setLocation({latitude: rawLat, longitude: rawLon});

          // --- Smoothed Distance Calculation with Buffer Accumulation ---
          if (!filteredLocation.current) {
            // Initialize the filtered location on the first update.
            filteredLocation.current = {latitude: rawLat, longitude: rawLon};
          } else {
            // Apply a low-pass filter to smooth out the raw GPS coordinates.
            const newFilteredLat =
              LPF_ALPHA * rawLat +
              (1 - LPF_ALPHA) * filteredLocation.current.latitude;
            const newFilteredLon =
              LPF_ALPHA * rawLon +
              (1 - LPF_ALPHA) * filteredLocation.current.longitude;
            const newFilteredLocation = {
              latitude: newFilteredLat,
              longitude: newFilteredLon,
            };

            // Compute the distance between the previous filtered position and the new one.
            const deltaDistance = calculateDistance(
              filteredLocation.current,
              newFilteredLocation,
            );
            // Always update the filtered location.
            filteredLocation.current = newFilteredLocation;

            // Accumulate the deltaDistance in the buffer.
            distanceBuffer.current += deltaDistance;

            // Once the accumulated distance exceeds our 2 m threshold, add it to total.
            if (distanceBuffer.current >= BASE_DISTANCE_THRESHOLD) {
              setDistanceTraveled(prev => prev + distanceBuffer.current);
              distanceBuffer.current = 0;
            }
          }
        }
      },
      error => console.log('Location Error: ', error),
      {
        enableHighAccuracy: true,
        distanceFilter: 0,
        interval: 250,
        fastestInterval: 250,
        forceRequestLocation: true,
        showsBackgroundLocationIndicator: true,
        pausesLocationUpdatesAutomatically: false,
        activityType: 'fitness',
        accuracy: Platform.OS === 'ios' ? 'bestForNavigation' : 'high',
        maximumAge: 0,
      },
    );
  };

  // ----------------------------------------------------------------
  // Utility: Calculate Distance using Haversine Formula
  // ----------------------------------------------------------------
  const calculateDistance = (coord1, coord2) => {
    const {latitude: lat1, longitude: lon1} = coord1;
    const {latitude: lat2, longitude: lon2} = coord2;
    const R = 6371e3; // Earth radius in meters
    const φ1 = (lat1 * Math.PI) / 180;
    const φ2 = (lat2 * Math.PI) / 180;
    const Δφ = ((lat2 - lat1) * Math.PI) / 180;
    const Δλ = ((lon2 - lon1) * Math.PI) / 180;
    const a =
      Math.sin(Δφ / 2) ** 2 +
      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };

  // ----------------------------------------------------------------
  // Stop Tracking: Clear Subscriptions and Compute Journey Metrics
  // ----------------------------------------------------------------
  const stopTracking = () => {
    setTracking(false);
    if (locationSubscription.current) {
      Geolocation.clearWatch(locationSubscription.current);
      locationSubscription.current = null;
    }
    // Finalize any pending stop detection.
    finalizeStop();
    // Compute average speed from recorded speed readings.
    const readings = speedReadings.current;
    const avgSpeed =
      readings.length > 0
        ? readings.reduce((a, b) => a + b, 0) / readings.length
        : 0;
    setAverageSpeed(avgSpeed);
    // Compute journey duration (in seconds).
    const journeyDuration = startTime ? (Date.now() - startTime) / 1000 : 0;
    setDuration(journeyDuration);

    // Announce stop using TTS.
    Tts.speak('Tracking stopped');
    setShowResults(true);
  };

  // ----------------------------------------------------------------
  // Cleanup: Stop All Sensors/Subscriptions on Component Unmount
  // ----------------------------------------------------------------
  const stopAllSensors = () => {
    if (locationSubscription.current) {
      Geolocation.clearWatch(locationSubscription.current);
      locationSubscription.current = null;
    }
    if (accelerometerSubscription.current) {
      accelerometerSubscription.current.unsubscribe();
      accelerometerSubscription.current = null;
    }
    if (stillAlertTimeoutRef.current) {
      clearTimeout(stillAlertTimeoutRef.current);
      stillAlertTimeoutRef.current = null;
    }
  };

  // ----------------------------------------------------------------
  // Handle Start Button: 3-Second Countdown Before Tracking Begins
  // ----------------------------------------------------------------
  const handleStartButton = () => {
    let count = 3;
    setCountdown(count);
    const interval = setInterval(() => {
      count -= 1;
      if (count === 0) {
        clearInterval(interval);
        setCountdown(null);
        startTrackingFunc();
      } else {
        setCountdown(count);
      }
    }, 1000);
  };

  // ----------------------------------------------------------------
  // Render UI
  // ----------------------------------------------------------------
  // Calculate total stop time (in milliseconds) from recorded stops.
  const totalStopTime = stops.reduce((acc, stop) => acc + stop.duration, 0);

  return (
    <PaperProvider>
      <View style={styles.container}>
        {/* Initial Screen: Profile and Start Button */}
        {!tracking && !showResults && (
          <>
            <ProfileCard />
            <TouchableOpacity style={styles.button} onPress={handleStartButton}>
              <Text style={styles.buttonText}>
                {countdown !== null ? countdown : 'Start Tracking'}
              </Text>
            </TouchableOpacity>
          </>
        )}

        {/* Ongoing Trip Screen */}
        {tracking && (
          <Card style={styles.card}>
            <Card.Content>
              <Title style={styles.title}>Ongoing Trip</Title>
              <Text style={styles.speedLabel}>Speed:</Text>
              <Text style={[styles.speedText, {color: 'green'}]}>
                {speed.toFixed(2)} m/s
              </Text>
              <Text style={styles.speedLabel}>Distance:</Text>
              <Text style={[styles.speedText, {color: 'blue'}]}>
                {distanceTraveled.toFixed(2)} m
              </Text>
              <View style={styles.buttonContainer}>
                <TouchableOpacity style={styles.button} onPress={stopTracking}>
                  <Text style={styles.buttonText}>Stop Journey</Text>
                </TouchableOpacity>
              </View>
            </Card.Content>
          </Card>
        )}

        {/* Journey Summary Screen */}
        {showResults && (
          <View style={styles.summaryContainer}>
            <Card style={styles.card}>
              <Card.Content>
                <Text style={styles.resultsTitle}>Journey Summary</Text>
                <ScrollView style={styles.summaryScrollView}>
                  <View style={styles.resultContainer}>
                    <Text style={styles.resultText}>
                      Average Speed:{' '}
                      <Text style={styles.resultValue}>
                        {averageSpeed.toFixed(2)} m/s
                      </Text>
                    </Text>
                    <Text style={styles.resultText}>
                      Total Distance:{' '}
                      <Text style={styles.resultValue}>
                        {distanceTraveled.toFixed(2)} meters
                      </Text>
                    </Text>
                    <Text style={styles.resultText}>
                      Journey Duration:{' '}
                      <Text style={styles.resultValue}>
                        {duration.toFixed(2)} seconds
                      </Text>
                    </Text>
                    {/* Display stop details */}
                    <Text style={styles.resultsTitle}>Stop Details</Text>
                    {stops.length > 0 ? (
                      stops.map((stop, index) => (
                        <Text key={index} style={styles.resultText}>
                          Stop {index + 1}: {(stop.duration / 1000).toFixed(2)}{' '}
                          seconds
                        </Text>
                      ))
                    ) : (
                      <Text style={styles.resultText}>No stops recorded.</Text>
                    )}
                    <Text style={styles.resultText}>
                      Total Stop Time:{' '}
                      <Text style={styles.resultValue}>
                        {(totalStopTime / 1000).toFixed(2)} seconds
                      </Text>
                    </Text>
                  </View>
                </ScrollView>
                <View style={styles.centeredButtonContainer}>
                  <TouchableOpacity
                    style={styles.button}
                    onPress={() => {
                      // Reset state for a new journey.
                      setShowResults(false);
                      setDistanceTraveled(0);
                      setSpeed(0);
                      setAverageSpeed(0);
                      setDuration(0);
                      setStops([]);
                    }}>
                    <Text style={styles.buttonText}>Back</Text>
                  </TouchableOpacity>
                </View>
              </Card.Content>
            </Card>
          </View>
        )}
      </View>
    </PaperProvider>
  );
}

// ----------------------------------------------------------------
// Styles
// ----------------------------------------------------------------
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'rgba(230,230,250,0.4)',
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  card: {
    width: '100%',
    borderRadius: 10,
    elevation: 5,
    backgroundColor: '#ffffff',
    marginVertical: 10,
  },
  title: {
    fontSize: 22,
    fontWeight: '600',
    color: '#333',
    textAlign: 'center',
    marginBottom: 20,
  },
  buttonContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 20,
  },
  button: {
    backgroundColor: '#6200ee',
    padding: 12,
    borderRadius: 5,
    marginVertical: 10,
    width: '45%',
    alignItems: 'center',
  },
  buttonText: {
    color: 'white',
    fontSize: 14,
    textAlign: 'center',
  },
  speedLabel: {
    fontSize: 16,
    fontWeight: '600',
    marginBottom: 5,
    color: '#333',
    textAlign: 'center',
  },
  speedText: {
    fontSize: 22,
    fontWeight: '600',
    marginBottom: 20,
    textAlign: 'center',
  },
  resultsTitle: {
    fontSize: 22,
    fontWeight: '600',
    marginBottom: 20,
    color: '#6200ee',
    textAlign: 'center',
  },
  resultContainer: {
    marginBottom: 20,
    paddingHorizontal: 10,
  },
  resultText: {
    fontSize: 14,
    marginBottom: 10,
    color: '#333',
  },
  resultValue: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#915F6D',
  },
  summaryContainer: {
    position: 'absolute',
    left: 20,
    right: 20,
  },
  summaryScrollView: {
    maxHeight: 500,
  },
  centeredButtonContainer: {
    alignItems: 'center',
    marginTop: 10,
  },
});

const toastStyles = StyleSheet.create({
  container: {
    backgroundColor: 'transparent',
    borderColor: 'transparent',
    borderWidth: 0,
    borderRadius: 0,
    paddingVertical: 8,
    paddingHorizontal: 12,
    alignItems: 'center',
    justifyContent: 'center',
  },
  causeText: {
    fontSize: 22,
    fontWeight: 'bold',
    color: '#6200ee',
    textAlign: 'center',
  },
  intensityText: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#d32f2f',
    textAlign: 'center',
  },
});
